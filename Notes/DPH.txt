DPH Notes:

1) Do not use $:

incsum :: [:Int:] -> Int
incsum xs = sumP(mapP (PI.+ 1) xs)
...works

incsum :: [:Int:] -> Int
incsum xs = sumP= $ mapP (PI.+ 1) xs
...does not.

*** Vectorisation error ***
    Variable not vectorised: GHC.Base.$

2) Need pragmas:

{-# LANGUAGE ParallelArrays #-}
{-# OPTIONS_GHC -fvectorise #-}

sometimes {-# NOINLINE incsumW #-} is useful.

3) Separate Vectorised from Non-vectorised:

*** Vectorisation error ***
    Tycon not vectorised:  GHC.Prim.RealWorld

indicates that perhaps you need to move your vectorised code into another module and import it and surround with NOINLINE

Compile as ghc --make -threaded -Odph simp...hs simp...Main.hs

(BTW: module names must be Capitalised)

4) Empty lists not valid for [: Int :]

quickSortP' :: [:Int:] -> [:Int:]
quickSortP' [::] = [::]
quickSortP' xs = ...

yielded:

[1 of 1] Compiling QuickSort        ( quickSortPar.hs, quickSortPar.o )
exprType TYPE ghc-prim:GHC.Types.Int{(w) tc 3J}
*** Vectorisation error ***
    Can't vectorise expression GHC.Prim.Int#

Removing the empty array expression and replacing it with one that accepts a list of a single item as the base case makes things work.

5) [::] is not an instance of Eq, but PArray is.

... filterP (/= leftNodeMST) msts
must become
... filterP (\mst -> (toPArrayP mst) /= (toPArrayP leftNodeMST))
but that is broken to. See (6)

6) /=, == on [::] not valid

I had to do some horrible comparison operation:
notEqualGraph :: Graph -> Graph -> Bool
notEqualGraph es fs = B.not (andP (mapP (\i -> equalEdge (indexP es i) (indexP fs i)) (enumFromToP 0 (lengthP es I.- 1))))
equalEdge :: Edge -> Edge -> Bool
equalEdge e@(n1, n2) f@(n3, n4) = n1 I.== n3 B.&& n2 I.== n4

7) Missing cons (:)

e : es
must become
(singleton e) +:+ es 

8) (e:es) pattern matching can be forced

blah (e:es) = f e + blah es
can become
blah es | lengthP es I.== 1 = f (es !: 0)
blah es = f (es !: 0) + blah (sliceP 1 ((lengthP es) I.- 1) es)

No guarantees on efficiency!

9) [::] should be replaced with emptyP

kruskal :: [:Edge:] -> [:Graph:] -> [:Graph:]
kruskal ... = [::]
Warning: vectorisation failure: vectAlgCase: data constructor not vectorised GHC.Types.I#

kruskal ... = emptyP

10) fst and snd do not work on PArray Tuple

blah e = f (snd e)

*** Vectorisation error ***
    Variable not vectorised: Data.Tuple.snd

blah e@(n1, n2) = f n2

11) ==

Int == Int becomes 
import Data.Array.Parallel.Prelude.Int as I
Int I.== Int